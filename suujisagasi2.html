<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Êï∞Â≠óÊé¢„ÅóËÑ≥„Éà„É¨„Ç≤„Éº„É† - Â§öÊï∞„Åã„Çâ1ÂÄãÊé¢„Åó</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: 'Arial', sans-serif;
      display: flex; justify-content: center; align-items: center;
      background-color: #3498db; color: #fff; user-select: none;
      padding: 1vh 1vw; box-sizing: border-box;
    }
    #game-container {
      width: 100%; height: 100%; max-width: 700px; max-height: 900px;
      display: flex; flex-direction: column; text-align: center;
      background-color: #2c3e50;
      padding: clamp(10px, 2vh, 20px); border-radius: 15px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.2); box-sizing: border-box;
      position: relative;
    }
    .header {
      display: flex; justify-content: space-between; align-items: center;
      flex-wrap: wrap; margin-bottom: clamp(10px,2vh,20px); flex-shrink: 0;
    }
    #question {
      font-size: clamp(1em, 3.5vw, 1.8em); font-weight: bold;
      background-color: #fff; color: #2c3e50;
      padding: 0.8vh 1.5vw; border-radius: 10px; flex-grow: 1; margin: 5px;
      order: 2;
    }
    #timer {
      font-size: clamp(1em, 3.5vw, 1.5em); font-weight: bold; color: #f1c40f;
      min-width: 70px; text-align: right; order: 3; display: none;
    }
    .header button, #difficulty-select {
      font-size: clamp(0.9em,3vw,1.2em); padding: 1vh 1.5vw;
      border: none; background-color: #f1c40f; color: #2c3e50; border-radius: 8px;
      cursor: pointer; transition: transform 0.1s, background-color 0.2s;
      margin: 5px; white-space: nowrap;
    }
    #reset-button { order: 1; }
    #endless-stop-button { order: 4; display: none; }
    #difficulty-select { order: 1; padding-right: 30px; }
    #difficulty-select {
      appearance: none;
      background-image: url('data:image/svg+xml;utf8,<svg fill="%232c3e50" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
      background-repeat: no-repeat; background-position: right 8px center;
    }
    .header button:active { transform: scale(0.95); }
    #game-board {
      position: relative; width: 100%; flex-grow: 1;
      background-color: #ecf0f1; border-radius: 10px; overflow: hidden;
      min-height: 0;
    }
    .number-cell {
      position: absolute;
      font-weight: bold; cursor: pointer;
      display: flex; justify-content: center; align-items: center;
      transition: opacity 0.3s, transform 0.1s;
      line-height: 1; padding: 2px; box-sizing: border-box; white-space: nowrap;
      background: #fff9; box-shadow: 0 2px 6px #8884; border-radius: 6px;
      outline: solid 2px #ddd6; z-index: 3; user-select: none;
    }
    .number-cell.found {
      opacity: 0.2; pointer-events: none; filter: grayscale(1);
    }
    #game-over-message {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.7); color: #fff; display: none;
      flex-direction: column; justify-content: center; align-items: center;
      border-radius: 10px; font-size: clamp(1.8em,6vw,2.5em); font-weight: bold;
      z-index: 20;
    }
    #game-over-message p { margin: 10px 0; }
    #final-time { color: #f1c40f; font-size: 1.2em; }
    #chart-section {
      display: none; position: absolute; top: 0; left: 0;
      width: 100%; height:100%; background: rgba(10,10,40, 0.95);
      z-index:22; justify-content: center; align-items: center; flex-direction:column;
    }
    #chart-canvas { max-width: 90vw; max-height: 50vh; background: #fff; border-radius: 16px; }
    #close-chart {
      margin-top:16px; padding: 1em 2em; font-size: 1.2em; background:#f1c40f; color:#2c3e50;
      border: none; border-radius: 8px; cursor: pointer;
      transition:background 0.2s;
    }
    #close-chart:active { background: #fff24a; }
    @media (max-width: 450px) {
      .header { flex-direction: row; justify-content: space-around; }
      #question { width: 100%; margin: 5px 0; text-align: center; }
      #timer { min-width: auto; }
    }
    .mode-selection {
      display: flex; align-items: center; flex-wrap:nowrap;
      margin-right: 15px; white-space: nowrap; order: 0;
    }
    .mode-selection input[type="radio"] { margin-right: 5px; }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="header">
      <div class="mode-selection">
        <input type="radio" id="timeMode" name="gameMode" value="time">
        <label for="timeMode">„Çø„Ç§„É†</label>
        <input type="radio" id="relaxMode" name="gameMode" value="relax" checked>
        <label for="relaxMode">„É™„É©„ÉÉ„ÇØ„Çπ</label>
      </div>
      <button id="reset-button" title="„É™„Çª„ÉÉ„Éà">üîÑ „É™„Çª„ÉÉ„Éà</button>
      <select id="difficulty-select">
        <option value="10">„ÇÑ„Åï„Åó„ÅÑ (10)</option>
        <option value="25">„Åµ„Å§„ÅÜ (25)</option>
      </select>
      <button id="endless-stop-button">ÁµÇ‰∫Ü</button>
      <div id="question"></div>
      <div id="timer">00:00</div>
    </div>
    
    <div id="game-board"></div>
    <div id="game-over-message">
      <p>„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ</p>
      <p id="final-time"></p>
    </div>
    <div id="chart-section">
      <canvas id="chart-canvas"></canvas>
      <button id="close-chart">Èñâ„Åò„Çã</button>
    </div>
  </div>

  <script>
    const COLORS = [
      '#e74c3c','#f39c12','#1abc9c','#2980b9','#8e44ad',
      '#2c3e50','#d35400','#c0392b','#16a085','#34495e',
      '#9b59b6','#3498db','#f1c40f','#e67e22','#7f8c8d'
    ];
    const MIN_NUMBER = 1, MAX_NUMBER = 100;
    const MAX_PLACEMENT_ATTEMPTS = 5000;

    const gameBoard = document.getElementById('game-board');
    const questionEl = document.getElementById('question');
    const resetButton = document.getElementById('reset-button');
    const difficultySelect = document.getElementById('difficulty-select');
    const timerEl = document.getElementById('timer');
    const gameOverMessage = document.getElementById('game-over-message');
    const finalTimeEl = document.getElementById('final-time');
    const timeModeRadio = document.getElementById('timeMode');
    const relaxModeRadio = document.getElementById('relaxMode');
    const endlessStopButton = document.getElementById('endless-stop-button');
    const chartSection = document.getElementById('chart-section');
    const closeChartBtn = document.getElementById('close-chart');
    const chartCanvas = document.getElementById('chart-canvas');

    let allNumbers = [], numbersPanel = [], numbersLeft = [], currentTarget = null;
    let gameStarted = false, startTime = 0, timerInterval = null;
    let currentDifficulty = 100, isTimeMode = false;
    let tapTimes = [], lastTapTime = 0, chartObj = null, handlingResize = false;
    let placedRects = [];

    function getRandomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
    function measureCellRect(cell) {
      return {
        left: parseFloat(cell.style.left),
        top: parseFloat(cell.style.top),
        width: cell.offsetWidth,
        height: cell.offsetHeight,
        get right() { return this.left + this.width; },
        get bottom() { return this.top + this.height; }
      };
    }
    function isOverlapping(newR, rects, pad=5) {
      for (const r of rects) {
        if (!(newR.right + pad < r.left - pad ||
              newR.left - pad > r.right + pad ||
              newR.bottom + pad < r.top - pad ||
              newR.top - pad > r.bottom + pad)) {
          return true;
        }
      }
      return false;
    }

    function findValidPosition(w, h, existingRects) {
      let attempts = 0;
      while (attempts < MAX_PLACEMENT_ATTEMPTS) {
        const top = getRandomInt(5, gameBoard.clientHeight - h - 5);
        const left = getRandomInt(5, gameBoard.clientWidth - w - 5);
        const rect = {
          left, top, width: w, height: h,
          get right() { return this.left + this.width; },
          get bottom() { return this.top + this.height; }
        };
        
        if (!isOverlapping(rect, existingRects, 8)) {
          return { left, top, rect };
        }
        attempts++;
      }
      return null;
    }

    function createNumberCell(num, fontSize, isRandom = true) {
      const cell = document.createElement('div');
      cell.classList.add('number-cell');
      cell.textContent = num;
      cell.dataset.number = num;
      cell.style.fontSize = fontSize + 'px';
      cell.style.color = COLORS[getRandomInt(0, COLORS.length - 1)];
      
      if (isRandom) {
        cell.style.transform = `rotate(${getRandomInt(-35, 35)}deg)`;
      } else {
        cell.style.transform = `rotate(0deg)`;
      }
      return cell;
    }
    
    function placeBoardNumbers(nums) {
      gameBoard.innerHTML = '';
      placedRects = [];
      const cellsToPlace = [...nums];
      let placementSucceeded = true;

      for (let i = 0; i < cellsToPlace.length; i++) {
        const fontMin = Math.min(18, gameBoard.clientHeight / 15);
        const fontMax = Math.max(24, gameBoard.clientHeight / 8);
        const cell = createNumberCell(cellsToPlace[i], getRandomInt(fontMin, fontMax));

        cell.style.visibility = 'hidden';
        gameBoard.appendChild(cell);
        const w = cell.offsetWidth, h = cell.offsetHeight;
        
        const pos = findValidPosition(w, h, placedRects);
        
        if (pos) {
          cell.style.left = pos.left + 'px';
          cell.style.top = pos.top + 'px';
          cell.style.visibility = 'visible';
          placedRects.push(pos.rect);
          cell.addEventListener('click', handleNumberClick);
        } else {
          gameBoard.removeChild(cell);
          placementSucceeded = false;
          break;
        }
      }

      if (placementSucceeded) {
        console.log('„Åô„Åπ„Å¶„ÅÆÊï∞Â≠ó„Çí„É©„É≥„ÉÄ„É†„Å´ÈÖçÁΩÆ„Åó„Åæ„Åó„Åü„ÄÇ');
      } else {
        console.warn('„É©„É≥„ÉÄ„É†ÈÖçÁΩÆ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇËá™Âãï„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÄÇ');
        setTimeout(setupGame, 100);
      }
    }

    function placeNumbersInGrid(nums) {
      gameBoard.innerHTML = '';
      placedRects = [];

      const boardW = gameBoard.clientWidth;
      const boardH = gameBoard.clientHeight;
      const cellMargin = 5;

      const tempCell = createNumberCell(nums[0], 20, false);
      gameBoard.appendChild(tempCell);
      const cellW = tempCell.offsetWidth;
      const cellH = tempCell.offsetHeight;
      gameBoard.removeChild(tempCell);

      const numCols = Math.floor(boardW / (cellW + cellMargin));
      const numRows = Math.ceil(nums.length / numCols);

      const totalGridWidth = numCols * (cellW + cellMargin);
      const totalGridHeight = numRows * (cellH + cellMargin);
      const startX = (boardW - totalGridWidth) / 2;
      const startY = (boardH - totalGridHeight) / 2;

      nums.forEach((num, index) => {
        const cell = createNumberCell(num, 20, false);
        const col = index % numCols;
        const row = Math.floor(index / numCols);

        cell.style.left = (startX + col * (cellW + cellMargin)) + 'px';
        cell.style.top = (startY + row * (cellH + cellMargin)) + 'px';

        gameBoard.appendChild(cell);
        cell.addEventListener('click', handleNumberClick);
      });
    }

    function setupGame() {
      if (chartObj) { chartObj.destroy(); chartObj = null; }
      chartSection.style.display = 'none';
      gameOverMessage.style.display = 'none';
      clearInterval(timerInterval);
      timerEl.textContent = '00:00';
      gameStarted = false;
      tapTimes = [];
      placedRects = [];
      endlessStopButton.style.display = isTimeMode ? 'none' : 'inline-block';
      timerEl.style.display = isTimeMode ? 'block' : 'none';
      
      allNumbers = [];
      for (let i = MIN_NUMBER; i <= MAX_NUMBER; i++) allNumbers.push(i);
      shuffleArray(allNumbers);
      numbersPanel = allNumbers.slice(0, currentDifficulty);
      numbersLeft = [...numbersPanel];
      shuffleArray(numbersLeft);
      
      placeBoardNumbers(numbersPanel);
      
      askNewQuestion(true);
    }

    function askNewQuestion(first = false) {
      if (!isTimeMode && numbersLeft.length === 0) {
        const existingNumbers = Array.from(gameBoard.querySelectorAll('.number-cell'))
          .map(c => parseInt(c.dataset.number, 10));
        
        const newNumberPool = allNumbers.filter(n => !existingNumbers.includes(n));
        
        if (newNumberPool.length > 0) {
          const newNumber = newNumberPool[getRandomInt(0, newNumberPool.length - 1)];
          const fontMin = Math.min(18, gameBoard.clientHeight / 15);
          const fontMax = Math.max(24, gameBoard.clientHeight / 8);
          const cell = createNumberCell(newNumber, getRandomInt(fontMin, fontMax));

          cell.style.visibility = 'hidden';
          gameBoard.appendChild(cell);
          const w = cell.offsetWidth, h = cell.offsetHeight;
          const pos = findValidPosition(w, h, placedRects);

          if(pos) {
            cell.style.left = pos.left + 'px';
            cell.style.top = pos.top + 'px';
            cell.style.visibility = 'visible';
            placedRects.push(pos.rect);
            cell.addEventListener('click', handleNumberClick);
            numbersLeft.push(newNumber);
          } else {
            gameBoard.removeChild(cell);
            const currentNumbersOnBoard = Array.from(gameBoard.querySelectorAll('.number-cell'))
              .map(c => parseInt(c.dataset.number, 10));
            numbersLeft = [...currentNumbersOnBoard];
            shuffleArray(numbersLeft);
          }
        }
      }
      
      if (isTimeMode && numbersLeft.length === 0) {
        endGame();
        return;
      }
      
      if (numbersLeft.length === 0) {
        return;
      }

      currentTarget = numbersLeft.shift();
      questionEl.textContent = `${currentTarget} „ÇíÊé¢„ÅõÔºÅ`;
      if (!gameStarted) {
        if (isTimeMode) {
          startTime = Date.now();
          timerInterval = setInterval(updateTimer, 1000);
        } else {
          startTime = Date.now();
          timerEl.textContent = '00:00';
        }
        gameStarted = true;
        lastTapTime = Date.now();
      }
    }

    function updateTimer() {
      const t = Date.now() - startTime;
      const m = Math.floor(t/60000), s = Math.floor((t%60000)/1000);
      timerEl.textContent =
        `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function handleNumberClick(e) {
      if (!gameStarted) return;
      const tapped = parseInt(e.target.dataset.number, 10);
      if (tapped !== currentTarget) return;

      const interval = (Date.now() - lastTapTime)/1000;
      lastTapTime = Date.now();
      if (!isTimeMode) tapTimes.push(interval);

      e.target.classList.add('found');
      numbersLeft = numbersLeft.filter(n => n !== tapped);

      if (isTimeMode) {
        if (numbersLeft.length === 0) {
          endGame();
        } else {
          askNewQuestion();
        }
      } else {
        const rect = measureCellRect(e.target);
        placedRects = placedRects.filter(r =>
          !(Math.abs(r.left - rect.left) < 1 && Math.abs(r.top - rect.top) < 1)
        );
        e.target.remove();
        
        const existing = Array.from(gameBoard.querySelectorAll('.number-cell'))
          .map(c => parseInt(c.dataset.number, 10));
        
        const pool = allNumbers.filter(n => !existing.includes(n));
        
        if (pool.length > 0) {
          const newNumber = pool[getRandomInt(0, pool.length - 1)];
          const fontMin = Math.min(18, gameBoard.clientHeight / 15);
          const fontMax = Math.max(24, gameBoard.clientHeight / 8);
          const cell = createNumberCell(newNumber, getRandomInt(fontMin, fontMax));

          cell.style.visibility = 'hidden';
          gameBoard.appendChild(cell);
          const w = cell.offsetWidth, h = cell.offsetHeight;
          const pos = findValidPosition(w, h, placedRects);

          if (pos) {
            cell.style.left = pos.left + 'px';
            cell.style.top = pos.top + 'px';
            cell.style.visibility = 'visible';
            placedRects.push(pos.rect);
            cell.addEventListener('click', handleNumberClick);
            numbersLeft.push(newNumber);
          } else {
            gameBoard.removeChild(cell);
          }
        }
        
        askNewQuestion();
      }
    }

    function endGame() {
      clearInterval(timerInterval);
      gameStarted = false;
      const finalTime = (Date.now() - startTime) / 1000;
      finalTimeEl.textContent = `„ÇØ„É™„Ç¢„Çø„Ç§„É†: ${finalTime.toFixed(2)} Áßí`;
      gameOverMessage.style.display = 'flex';
    }

    resetButton.addEventListener('click', setupGame);
    difficultySelect.addEventListener('change', ev => {
      currentDifficulty = parseInt(ev.target.value, 10);
      localStorage.setItem('gameDifficulty', currentDifficulty);
      setupGame();
    });
    timeModeRadio.addEventListener('change', () => {
      isTimeMode = true;
      setupGame();
    });
    relaxModeRadio.addEventListener('change', () => {
      isTimeMode = false;
      setupGame();
    });
    endlessStopButton.addEventListener('click', () => {
      if (!tapTimes.length) return;
      showTapTimesChart();
    });

    function showTapTimesChart() {
      chartSection.style.display = 'flex';
      if (chartObj) chartObj.destroy();
      chartObj = new Chart(chartCanvas, {
        type: 'line',
        data: {
          labels: tapTimes.map((v,i)=>`${i+1}ÂõûÁõÆ`),
          datasets:[{
            label:'Áô∫Ë¶ã„Å´„Åã„Åã„Å£„ÅüÁßí',
            data: tapTimes,
            borderColor:'#f1c40f',
            fill:false, pointBackgroundColor:'#e74c3c'
          }]
        },
        options:{
          responsive:true, maintainAspectRatio:false,
          plugins:{
            legend:{display:false},
            title:{display:true,text:'Êï∞Â≠óÁô∫Ë¶ã„Å´„Åã„Åã„Å£„ÅüÊôÇÈñìÂ±•Ê≠¥'}
          },
          scales:{
            y:{beginAtZero:true,title:{display:true,text:'Áßí'}},
            x:{title:{display:true,text:'Áô∫Ë¶ãÊï∞ÔºàÂõûÔºâ'}}
          }
        }
      });
    }

    closeChartBtn.addEventListener('click', ()=> {
      chartSection.style.display = 'none';
    });

    let resizeTimer;
    window.addEventListener('resize', ()=> {
      if (handlingResize) return;
      handlingResize = true;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=> {
        setupGame();
        handlingResize = false;
      }, 300);
    });

    window.addEventListener('DOMContentLoaded', ()=> {
      const saved = localStorage.getItem('gameDifficulty');
      if (saved) {
        currentDifficulty = parseInt(saved, 10);
        difficultySelect.value = currentDifficulty;
      }
      setTimeout(()=> {
        isTimeMode = timeModeRadio.checked;
        setupGame();
      }, 50);
    });
  </script>
</body>
</html>
