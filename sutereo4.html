<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>è¶…è¦–èªæ€§ã‚¹ãƒ†ãƒ¬ã‚ªã‚°ãƒ©ãƒ ãƒ»çœŸ</title>
  <style>
    :root {
      --bg-color: #020617;
      --card-bg: #1e293b;
      --highlight: #f43f5e;
      --text-color: #f1f5f9;
      --correct: #10b981;
    }
    
    * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: 'Hiragino Kaku Gothic ProN', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    .container {
      width: 100%;
      max-width: 800px;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
    }

    h1 { font-size: 1.05rem; color: var(--highlight); margin: 4px 0; }

    /* ãƒ¡ã‚¤ãƒ³ã‚­ãƒ£ãƒ³ãƒã‚¹ */
    .canvas-wrapper {
      position: relative;
      margin: 6px 0;
      background: #000;
      border-radius: 8px;
      line-height: 0;
      box-shadow: 0 0 30px rgba(0,0,0,1);
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 8px;
      image-rendering: pixelated; /* ç ‚åµã‚’ã¯ã£ãã‚Šã•ã›ã‚‹ */
      display: block;
    }

    /* è¨­å®šã‚¨ãƒªã‚¢ */
    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 4px;
      align-items: center;
    }
    select, button {
      padding: 10px 6px;
      border-radius: 10px;
      border: none;
      font-size: 0.95rem;
      font-weight: bold;
      cursor: pointer;
    }
    #changeNumber { background: #3b82f6; color: white; }
    #recoveryMode { background: #8b5cf6; color: white; }
    .mode-active { box-shadow: 0 0 12px white; }

    /* å·¨å¤§å…¥åŠ›æ¬„ï¼ˆæ•°å­—ã‚µã‚¤ã‚ºã‚’2.5å€ã€ãŸã ã—ç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«èª¿æ•´ï¼‰ */
    .input-display {
      background: #000;
      margin-bottom: 6px;
      padding: 8px 10px;
      border-radius: 12px;
      /* ã‚‚ã¨ã®2.5remã‚’2.5å€ -> 6.25rem ã‚’ç›®å®‰ã«ã™ã‚‹ãŒ clamp ã§ç”»é¢å¹…ã«åˆã‚ã›ã‚‹ */
      font-size: clamp(1.6rem, 6.25rem, 10vw);
      font-weight: bold;
      min-height: 56px;
      color: #fff;
      border: 2px solid #334155;
      word-break: keep-all;
      display: flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      overflow: hidden;
    }

    /* å·¨å¤§ãƒ†ãƒ³ã‚­ãƒ¼ */
    .numpad {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      padding: 0 6px 8px 6px;
    }
    .num-btn {
      background: #334155;
      color: white;
      padding: 14px 0;
      font-size: calc(1.6rem + 0.6vw);
      border-radius: 12px;
      min-height: 52px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .num-btn:active { background: #475569; }
    .num-btn.submit { background: var(--highlight); grid-column: span 2; }
    .num-btn.del { background: #64748b; }

    /* çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
    #resultOverlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      font-size: 1.8rem;
    }
    .ans-val { font-size: 5rem; color: white; margin: 20px; }

    .option-row { margin: 6px 0; font-size: 0.85rem; display: flex; justify-content: center; gap: 12px; align-items: center; }

    /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–èª¿æ•´: å°ã•ã„ç”»é¢ã§ãƒœã‚¿ãƒ³ãŒã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    @media (max-width: 480px) {
      body { padding: 6px; }
      h1 { font-size: 1rem; }
      .controls { grid-template-columns: 1fr 1fr; gap: 6px; }
      select, button { padding: 8px 6px; font-size: 0.9rem; }
      .input-display { font-size: clamp(1.2rem, 6.25rem, 14vw); padding: 6px 8px; min-height: 48px; }
      .canvas-wrapper { margin: 6px 0; }
      .numpad { gap: 6px; padding: 0 4px 6px 4px; max-width: 100%; }
      .num-btn { padding: 10px 0; font-size: 1.4rem; min-height: 44px; border-radius: 10px; }
      .option-row { gap: 8px; font-size: 0.82rem; }
    }

    /* ã•ã‚‰ã«å°ã•ã„ç«¯æœ« */
    @media (max-width: 360px) {
      .controls { grid-template-columns: 1fr; gap: 6px; }
      .num-btn { font-size: 1.2rem; padding: 8px 0; min-height: 40px; }
      .input-display { font-size: clamp(1rem, 6.25rem, 18vw); min-height: 44px; }
      h1 { font-size: 0.95rem; }
    }

    /* é«˜ã•åˆ¶é™ã‚’ä½¿ã£ã¦ã‚¹ãƒãƒ›ç¸¦ç”»é¢ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã—ã«åã‚ã‚„ã™ãã™ã‚‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ç«¯æœ«ã«ã‚ˆã‚Šå·®ã‚ã‚Šï¼‰ */
    @media (orientation: portrait) and (max-width: 480px) {
      /* ç”»é¢é«˜ã•ã«å¿œã˜ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¡¨ç¤ºé ˜åŸŸã‚’åˆ¶é™ */
      .canvas-wrapper { max-height: calc(100vh - 56px - 48px - 56px - 200px); } /* ãƒ˜ãƒƒãƒ€+controls+input+numpadé ˜åŸŸã‚’æƒ³å®šã—ã¦æ®‹ã™ */
      .canvas-wrapper canvas { height: 28vh; width: 100%; object-fit: cover; }
    }
  </style>
</head>
<body>

<div class="container">
  <h1>ğŸ‘ï¸ è¶…è¦–èªæ€§ã‚¹ãƒ†ãƒ¬ã‚ªã‚°ãƒ©ãƒ ãƒ»çœŸ</h1>
  
  <div class="controls">
    <select id="levelSelect">
      <option value="1">1æ¡</option>
      <option value="2">2æ¡</option>
      <option value="3">3æ¡</option>
      <option value="4">4æ¡</option>
      <option value="5">5æ¡</option>
      <option value="6">6æ¡</option>
    </select>
    <button id="changeNumber">ğŸ”„ æ¬¡ã®å•é¡Œ</button>
  </div>

  <div class="option-row">
    <label><input type="checkbox" id="bwMode" checked> ç™½é»’ãƒ¢ãƒ¼ãƒ‰</label>
    <button id="recoveryMode" style="padding: 5px 10px; font-size: 0.8rem;">ğŸ§˜ è¦–åŠ›å›å¾© OFF</button>
  </div>

  <div class="canvas-wrapper">
    <!-- ã‚¹ãƒ†ãƒ¬ã‚ªã‚°ãƒ©ãƒ æœ¬ä½“ -->
    <canvas id="stereoCanvas" width="800" height="450"></canvas>
  </div>

  <div class="input-display" id="guessDisplay" aria-live="polite"></div>

  <div class="numpad">
    <button class="num-btn" data-val="7">7</button>
    <button class="num-btn" data-val="8">8</button>
    <button class="num-btn" data-val="9">9</button>
    <button class="num-btn" data-val="4">4</button>
    <button class="num-btn" data-val="5">5</button>
    <button class="num-btn" data-val="6">6</button>
    <button class="num-btn" data-val="1">1</button>
    <button class="num-btn" data-val="2">2</button>
    <button class="num-btn" data-val="3">3</button>
    <button class="num-btn del" data-val="del">æ¶ˆ</button>
    <button class="num-btn" data-val="0">0</button>
    <button class="num-btn submit" id="submitBtn">å›ç­”</button>
  </div>
</div>

<div id="resultOverlay">
  <div id="resultStatus"></div>
  <div class="ans-val" id="correctValue"></div>
  <div style="font-size: 1rem;">æ¬¡ã®å•é¡Œã¸é€²ã¿ã¾ã™...</div>
</div>

<script>
  const canvas = document.getElementById('stereoCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  
  let currentAnswer = "";
  let currentGuess = "";
  let recoveryActive = false;
  let recoveryFrame = 0;

  // å®Œå…¨ã«å‡ä¸€ãªç ‚åµã‚’ä½œã‚‹ãŸã‚ã®è¨­å®š
  const DPI = 72;
  const EYE_SEP = DPI * 2.5; // æ¨™æº–çš„ãªç›®ã®é–“éš”
  const MU = 0.33; // å¥¥è¡Œãä¿‚æ•°

  function getRandomColor() {
    const isBW = document.getElementById('bwMode').checked;
    if (isBW) {
      const v = Math.random() > 0.5 ? 255 : 0; // ç™½ã‹é»’ã®2å€¤ã«ã™ã‚‹ã¨æœ€ã‚‚éš è”½æ€§ãŒé«˜ã„
      return [v, v, v];
    } else {
      const r = Math.random() > 0.5 ? 255 : 0;
      const g = Math.random() > 0.5 ? 255 : 0;
      const b = Math.random() > 0.5 ? 255 : 0;
      return [r, g, b];
    }
  }

  // éš ã—ç”»åƒã®ç”Ÿæˆï¼ˆãƒ¡ãƒ¢ãƒªä¸Šã®ã¿ï¼‰
  // å¤‰æ›´ç‚¹: å„æ¡ã‚’å€‹åˆ¥ã«æç”»ã—ã¦ã€æ•°å­—åŒå£«ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«é…ç½®ã™ã‚‹
  function getDepthData(text) {
    const dCanvas = document.createElement('canvas');
    dCanvas.width = W;
    dCanvas.height = H;
    const dCtx = dCanvas.getContext('2d');
    dCtx.fillStyle = "black";
    dCtx.fillRect(0, 0, W, H);

    // æ–‡å­—åˆ—ã‚’æ¡ã”ã¨ã«åˆ†å‰²ã—ã¦å€‹åˆ¥ã«æç”»
    const digits = text.split('');
    const n = digits.length;

    // ãƒ™ãƒ¼ã‚¹ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼ˆå…ƒã®å€¤ï¼‰ã‚’ç”¨æ„ã—ã€2.5å€ã‚’ç›®æ¨™ã«ã™ã‚‹ãŒã€ç”»é¢å¹…ã¨é«˜ã•ã«åã¾ã‚‹ã‚ˆã†ã«èª¿æ•´ã™ã‚‹
    // æ¡æ•°ã«å¿œã˜ãŸå…ƒã‚µã‚¤ã‚ºï¼ˆä»¥å‰ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¸è¥²ï¼‰
    let baseSize;
    if (n === 1) baseSize = 380;
    else if (n === 2) baseSize = 280;
    else if (n === 3) baseSize = 220;
    else if (n === 4) baseSize = 160;
    else if (n === 5) baseSize = 120;
    else baseSize = 90; // 6æ¡ã®å…ƒã‚µã‚¤ã‚º

    // ç›®æ¨™ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼ˆ2.5å€ï¼‰
    let fontSize = Math.floor(baseSize * 2.5);

    // ã¾ãšä»®ã®ãƒ•ã‚©ãƒ³ãƒˆã§å„æ¡ã®å¹…ã‚’æ¸¬ã‚‹
    dCtx.font = `900 ${fontSize}px sans-serif`;
    let widths = digits.map(d => dCtx.measureText(d).width);
    let totalWidth = widths.reduce((a,b)=>a+b,0);
    // æœ€ä½é™ã®é–“éš”ï¼ˆæ¡é–“ã‚¹ãƒšãƒ¼ã‚¹ï¼‰ã‚’ç¢ºä¿ã™ã‚‹ï¼ˆæ¡å¹…ã®10%ã‚’ç›®å®‰ï¼‰
    const gapTarget = Math.max(8, fontSize * 0.08);
    let requiredWidth = totalWidth + gapTarget * (n - 1);

    // ç”»é¢å¹…ã®90%ã‚’è¶…ãˆã‚‹å ´åˆã€ã¾ãŸã¯ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºãŒã‚­ãƒ£ãƒ³ãƒã‚¹é«˜ã•ã®90%ã‚’è¶…ãˆã‚‹å ´åˆã¯ç¸®å°
    const maxAllowedWidth = W * 0.9;
    const maxAllowedHeight = H * 0.9;

    while ((requiredWidth > maxAllowedWidth || fontSize > maxAllowedHeight) && fontSize > 8) {
      fontSize = Math.floor(fontSize * 0.95);
      dCtx.font = `900 ${fontSize}px sans-serif`;
      for (let i = 0; i < n; i++) widths[i] = dCtx.measureText(digits[i]).width;
      const newTotal = widths.reduce((a,b)=>a+b,0);
      const newGap = Math.max(6, fontSize * 0.08);
      if (newTotal + newGap * (n - 1) === requiredWidth) {
        // avoid infinite loop if nothing changes
        break;
      }
      requiredWidth = newTotal + newGap * (n - 1);
    }

    // æœ€çµ‚çš„ãªæ¡é–“éš”ã‚’æ±ºå®šï¼ˆæ®‹ã‚Šå¹…ã‚’å‡ç­‰ã«é…åˆ†ã—ã¦æ¡é–“ã‚’åºƒã’ã‚‹ï¼‰
    const measuredTotal = widths.reduce((a,b)=>a+b,0);
    let gap = Math.max(6, fontSize * 0.06);
    if (measuredTotal + gap * (n - 1) < maxAllowedWidth) {
      // ä½™ç™½ãŒã‚ã‚Œã°å‡ç­‰ã«åºƒã’ã‚‹ï¼ˆãŸã ã—éåº¦ã«ã¯åºƒã’ãªã„ï¼‰
      const extra = maxAllowedWidth - (measuredTotal + gap * (n - 1));
      const addPerGap = Math.min(extra / Math.max(1, n - 1), fontSize * 0.5);
      gap += addPerGap;
    } else {
      // å¹…ãŒå³ã—ã„å ´åˆã¯ç¸®ã‚ã‚‹
      while (measuredTotal + gap * (n - 1) > maxAllowedWidth && gap > 2) {
        gap *= 0.95;
      }
    }

    // æ¨ªæ–¹å‘ã®é–‹å§‹ä½ç½®ï¼ˆä¸­å¤®æƒãˆï¼‰
    const totalUsed = measuredTotal + gap * (n - 1);
    let startX = (W - totalUsed) / 2;

    // ç¸¦ä½ç½®ã¯ä¸­å¤®
    const centerY = H / 2 + 20;

    dCtx.textAlign = 'left';
    dCtx.textBaseline = 'middle';
    dCtx.fillStyle = "white";
    dCtx.shadowColor = "white";
    dCtx.shadowBlur = 15;

    // æç”»ï¼šå„æ¡ã‚’å€‹åˆ¥ã«æç”»ã—ã¦é‡ãªã‚Šã‚’é˜²ã
    for (let i = 0; i < n; i++) {
      dCtx.font = `900 ${fontSize}px sans-serif`;
      const x = startX;
      dCtx.fillText(digits[i], x, centerY);
      startX += widths[i] + gap;
    }

    return dCtx.getImageData(0, 0, W, H).data;
  }

  // SIRDSã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆãƒ”ã‚¯ã‚»ãƒ«é€£çµæ³•ï¼‰
  function drawSIRDS(offset = 0) {
    const depthData = getDepthData(currentAnswer);
    const imgData = ctx.createImageData(W, H);
    
    const curEyeSep = EYE_SEP + offset;

    for (let y = 0; y < H; y++) {
      const left = new Int32Array(W);
      const right = new Int32Array(W);
      
      for (let x = 0; x < W; x++) { left[x] = x; right[x] = x; }

      for (let x = 0; x < W; x++) {
        // æ·±åº¦å–å¾— (0.0 - 1.0)
        const z = depthData[(y * W + x) * 4] / 255;
        // åˆ†é›¢è·é›¢ã®è¨ˆç®—
        const sep = Math.floor((1 - MU * z) * curEyeSep / (2 - MU * z));
        
        let l = Math.floor(x - sep / 2);
        let r = l + sep;

        if (l >= 0 && r < W) {
          // ãƒ”ã‚¯ã‚»ãƒ«ã‚’ãƒªãƒ³ã‚¯ã•ã›ã‚‹ï¼ˆåŒã˜è‰²ã«ã™ã‚‹æŒ‡ç¤ºï¼‰
          let visible = true;
          // éš é¢æ¶ˆå»ã®ç°¡æ˜“åˆ¤å®š
          if (visible) {
            left[r] = l;
            right[l] = r;
          }
        }
      }

      const rowColors = new Uint8ClampedArray(W * 3);
      for (let x = 0; x < W; x++) {
        if (left[x] === x) {
          const c = getRandomColor();
          rowColors[x * 3] = c[0];
          rowColors[x * 3 + 1] = c[1];
          rowColors[x * 3 + 2] = c[2];
        } else {
          // ãƒªãƒ³ã‚¯ã•ã‚ŒãŸãƒ”ã‚¯ã‚»ãƒ«ã®è‰²ã‚’ã‚³ãƒ”ãƒ¼
          rowColors[x * 3] = rowColors[left[x] * 3];
          rowColors[x * 3 + 1] = rowColors[left[x] * 3 + 1];
          rowColors[x * 3 + 2] = rowColors[left[x] * 3 + 2];
        }
      }

      for (let x = 0; x < W; x++) {
        const idx = (y * W + x) * 4;
        imgData.data[idx] = rowColors[x * 3];
        imgData.data[idx+1] = rowColors[x * 3 + 1];
        imgData.data[idx+2] = rowColors[x * 3 + 2];
        imgData.data[idx+3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    drawGuideDots(offset);
  }

  function drawGuideDots(offset = 0) {
    const dotY = 25;
    const centerX = W / 2;
    const sep = (EYE_SEP + offset) / 2.8; 
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(centerX - sep, dotY, 5, 0, 7);
    ctx.arc(centerX + sep, dotY, 5, 0, 7);
    ctx.fill();
  }

  function initGame() {
    const mode = document.getElementById('levelSelect').value;
    if (mode === "1") currentAnswer = Math.floor(Math.random() * 10).toString();
    else if (mode === "2") currentAnswer = Math.floor(Math.random() * 90 + 10).toString();
    else if (mode === "3") currentAnswer = Math.floor(Math.random() * 900 + 100).toString();
    else if (mode === "4") currentAnswer = Math.floor(Math.random() * 9000 + 1000).toString();
    else if (mode === "5") currentAnswer = Math.floor(Math.random() * 90000 + 10000).toString();
    else currentAnswer = Math.floor(Math.random() * 900000 + 100000).toString();

    currentGuess = "";
    document.getElementById('guessDisplay').textContent = "";
    document.getElementById('resultOverlay').style.display = "none";
    drawSIRDS();
    adjustGuessFont(); // åˆæœŸåŒ–æ™‚ã«è¡¨ç¤ºé ˜åŸŸã«åã‚ã‚‹
  }

  // è¦–åŠ›å›å¾©ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  function animate() {
    if (!recoveryActive) return;
    recoveryFrame += 0.04;
    const offset = Math.sin(recoveryFrame) * 20;
    drawSIRDS(offset);
    requestAnimationFrame(animate);
  }

  // å…¥åŠ›å‡¦ç†
  const guessDisplay = document.getElementById('guessDisplay');
  document.querySelectorAll('.num-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const val = btn.dataset.val;
      if (val === 'del') currentGuess = currentGuess.slice(0, -1);
      else if (val) { if (currentGuess.length < 6) currentGuess += val; } // æœ€å¤§6æ¡ã«åˆ¶é™
      guessDisplay.textContent = currentGuess;
      adjustGuessFont(); // æ–‡å­—ãŒå¤‰ã‚ã‚‹ãŸã³ã«èª¿æ•´
    });
  });

  document.getElementById('submitBtn').addEventListener('click', () => {
    if (!currentGuess) return;
    const overlay = document.getElementById('resultOverlay');
    const status = document.getElementById('resultStatus');
    const correctVal = document.getElementById('correctValue');
    
    overlay.style.display = "flex";
    correctVal.textContent = currentAnswer;
    
    if (currentGuess === currentAnswer) {
      status.textContent = "æ­£è§£ï¼ ç´ æ™´ã‚‰ã—ã„ï¼";
      status.style.color = "#10b981";
    } else {
      status.textContent = "æ®‹å¿µï¼ æ­£è§£ã¯...";
      status.style.color = "#f43f5e";
    }
    
    setTimeout(initGame, 2500);
  });

  document.getElementById('changeNumber').addEventListener('click', initGame);
  document.getElementById('recoveryMode').addEventListener('click', (e) => {
    recoveryActive = !recoveryActive;
    e.target.textContent = recoveryActive ? "ğŸ§˜ è¦–åŠ›å›å¾© ON" : "ğŸ§˜ è¦–åŠ›å›å¾© OFF";
    if (recoveryActive) animate(); else drawSIRDS();
  });

  // åˆæœŸåŒ–æ™‚ã«ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’ç«¯æœ«ã«åˆã‚ã›ã¦èª¿æ•´ï¼ˆè¦‹ãŸç›®ã®é«˜ã•ã‚’æŠ‘ãˆã‚‹ï¼‰
  function adjustCanvasDisplay() {
    if (window.matchMedia("(orientation: portrait) and (max-width: 480px)").matches) {
      canvas.style.height = Math.max(window.innerHeight * 0.28, 140) + "px";
    } else {
      canvas.style.height = "auto";
    }
    drawSIRDS();
  }

  // guessDisplay ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’å‹•çš„ã«èª¿æ•´ã—ã¦ã€æ•°å­—ãŒç”»é¢ã‹ã‚‰ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«ã™ã‚‹
  function adjustGuessFont() {
    const el = guessDisplay;
    // åŸºæœ¬ã®æœ€å¤§ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼ˆ2.5å€ç›¸å½“ï¼‰ã‚’ãƒ”ã‚¯ã‚»ãƒ«ã§å–å¾—
    const containerWidth = el.clientWidth - 20; // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°åˆ†ã‚’å·®ã—å¼•ã
    if (!containerWidth) return;
    const rootFont = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
    let targetPx = 6.25 * rootFont; // 6.25rem ã® px å€¤ï¼ˆç›®æ¨™ï¼‰
    const maxByVw = Math.max(window.innerWidth * 0.10, 24);
    targetPx = Math.min(targetPx, Math.max(window.innerWidth * 0.18, maxByVw));

    el.style.fontSize = targetPx + "px";
    let currentSize = targetPx;
    // æ¨ªå¹…ã«åã¾ã‚‹ã‚ˆã†ã«ç¸®å°
    while (el.scrollWidth > containerWidth && currentSize > 12) {
      currentSize = Math.floor(currentSize * 0.95);
      el.style.fontSize = currentSize + "px";
      if (currentSize < 13) break;
    }
    // ç¸¦æ–¹å‘ã«ã‚‚åã‚ã‚‹
    const maxHeight = Math.max(44, window.innerHeight * 0.08);
    if (el.clientHeight > maxHeight) {
      while (el.clientHeight > maxHeight && currentSize > 12) {
        currentSize = Math.floor(currentSize * 0.95);
        el.style.fontSize = currentSize + "px";
        if (currentSize < 13) break;
      }
    }
  }

  window.addEventListener('resize', () => {
    adjustCanvasDisplay();
    adjustGuessFont();
  });

  window.onload = () => {
    initGame();
    adjustCanvasDisplay();
    adjustGuessFont();
  };
</script>
</body>
</html>